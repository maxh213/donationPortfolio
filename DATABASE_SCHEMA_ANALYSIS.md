# Database Schema Analysis for Donation Portfolio

## Overview
This analysis evaluates the proposed database schema in TODO.md against the project requirements and Supabase best practices. The donation portfolio application requires user authentication, charity management, donation tracking, and analytics capabilities.

## Project Requirements Analysis

Based on README.md, the application needs to support:
1. **User Management**: Auth0 integration with profile data storage
2. **Charity Management**: Logo storage via Cloudinary, categorization
3. **Cause Areas**: Flexible categorization system for charities
4. **Donation Tracking**: Monthly/yearly tracking with currency support
5. **Analytics**: Visualizations by time periods and cause areas

## Recommended Database Schema

### 1. User Profiles (`public.profiles`)
```sql
create table public.profiles (
  id uuid references auth.users(id) on delete cascade primary key,
  email text not null,
  full_name text,
  profile_picture_url text,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

alter table public.profiles enable row level security;
```

**Rationale**: 
- Links to Supabase's built-in `auth.users` table (Auth0 integration)
- Stores user-specific profile data
- RLS ensures users can only access their own profile

### 2. Cause Areas (`public.cause_areas`)
```sql
create table public.cause_areas (
  id bigint generated by default as identity primary key,
  name text not null unique,
  description text,
  color_hex varchar(7), -- For UI theming
  created_by uuid references auth.users(id) on delete cascade,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

alter table public.cause_areas enable row level security;
```

**Rationale**:
- User-owned cause areas for personalization
- Color coding for better UX
- Global cause areas can be managed via service_role

### 3. Charities (`public.charities`)
```sql
create table public.charities (
  id bigint generated by default as identity primary key,
  name text not null,
  website_url text,
  description text,
  logo_url text, -- Cloudinary URL
  primary_cause_area_id bigint references public.cause_areas(id),
  created_by uuid references auth.users(id) on delete cascade,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),
  
  constraint valid_website_url check (
    website_url is null or 
    website_url ~ '^https?://'
  )
);

alter table public.charities enable row level security;
```

**Rationale**:
- User-owned charities with optional sharing capability
- Single primary cause area (can be extended with junction table if needed)
- URL validation via check constraint
- Cloudinary logo storage

### 4. Charity-Cause Area Junction Table (Optional for Many-to-Many)
```sql
create table public.charity_cause_areas (
  charity_id bigint references public.charities(id) on delete cascade,
  cause_area_id bigint references public.cause_areas(id) on delete cascade,
  created_at timestamptz default now(),
  
  primary key (charity_id, cause_area_id)
);

alter table public.charity_cause_areas enable row level security;
```

**Rationale**: Only needed if charities belong to multiple cause areas

### 5. Donations (`public.donations`)
```sql
create table public.donations (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users(id) on delete cascade not null,
  charity_id bigint references public.charities(id) on delete restrict not null,
  amount decimal(12,2) not null check (amount > 0),
  currency varchar(3) not null default 'USD',
  donation_date date not null,
  notes text,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

alter table public.donations enable row level security;

-- Index for common queries
create index idx_donations_user_date on public.donations(user_id, donation_date desc);
create index idx_donations_user_charity on public.donations(user_id, charity_id);
```

**Rationale**:
- Precise decimal type for money amounts
- Date-based for monthly/yearly analytics
- Indexes for common query patterns
- ON DELETE RESTRICT for charities to preserve donation history

## Row Level Security Policies

### Profiles
```sql
create policy "Users can view own profile" on public.profiles
  for all to authenticated using (auth.uid() = id);
```

### Cause Areas
```sql
create policy "Users can manage own cause areas" on public.cause_areas
  for all to authenticated using (auth.uid() = created_by);

create policy "Users can view all cause areas" on public.cause_areas
  for select to authenticated using (true);
```

### Charities
```sql
create policy "Users can manage own charities" on public.charities
  for all to authenticated using (auth.uid() = created_by);

create policy "Users can view all charities" on public.charities
  for select to authenticated using (true);
```

### Donations
```sql
create policy "Users can manage own donations" on public.donations
  for all to authenticated using (auth.uid() = user_id);
```

## What Was Wrong With Original TODO.md Schema

1. **Over-engineered**: Separate tables for all operations when user-owned data model is simpler
2. **Missing RLS considerations**: No policies defined
3. **No indexing strategy**: Missing performance considerations
4. **Rigid structure**: Didn't account for user-specific vs shared data
5. **Missing data validation**: No check constraints
6. **Complex junction tables**: Unnecessary complexity for MVP

## Database Migration Strategy

1. Create tables in dependency order: cause_areas → charities → donations
2. Enable RLS on all tables
3. Create policies for user data isolation
4. Add indexes for query performance
5. Use Supabase's built-in auth.users table integration

## Future Enhancements Support

This schema supports:
- **Bank sync**: Add `external_transaction_id` to donations
- **Goals**: Add `donation_goals` table
- **Charity metrics**: Add `charity_metrics` table
- **Public profiles**: Modify RLS policies
- **Recommended charities**: Add system-managed charities

## Conclusion

The original TODO.md schema was overly complex for the MVP requirements. The recommended schema:
- Follows Supabase best practices
- Implements proper RLS for data security
- Supports the MVP requirements efficiently
- Provides foundation for future enhancements
- Reduces implementation complexity

The database design should prioritize user data isolation, performance, and extensibility while keeping the MVP implementation simple and secure.